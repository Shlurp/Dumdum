# **LESSON 11**
*Compiler and interpreter overview*

In order to fully use Strudel, you must understand its compiler and interpreter. You need to know the basics of how they operate, and how to use them.

Let's start with the compiler, which is more complicated than the interpreter. 

## **The compiler**
The compiler, which is the executable `cstru` (which stands for **Stru**del **C**ompiler) takes input source (or object) files and turns them into bytecode that is understandable by the Strudel interpreter.

### Operation
The compiler operates like so:
1. It iterates over input files, and compiles them into Strudel object files, which are just Strudel "executables" without justified variables. This means that while in an "executable" you may have the instruction: `JMP 100` which jumps to some offset in the file, in the object file, it would be: `JMP 0`. At the beginning of the object file is data concerning the variables declared and referenced in the file. This allows for the next step
2. The object files are compiled together, their variables justified, into an "executable".

### Usage
The compiler has the following usage:  
<code>cstru [<u>FLAGS</u>]... <<u>FILES</u>>... [-o <u>DEST</u>]</code>  

The files <u>FILES</u> are converted into bytecode and stored in the file <u>DEST</u>.

The compiler supports the following flags:

+ `h` - the help flag, it'll print some quick information on the compiler
+ `o` - the output redirection flag. Using this you can set where you'd like the output of the compiler (an executable or object file) to go. If this is flag is not raised, the output will be written to a file named `stru.out`.
+ `c` - compile only. Convert source file into object file, but do not link. **Only one source file ca be input if this flag is raised.**
+ `l` - link only. Take object files and link, convert to executable.
+ `i` - print instructions. This is for debugging. It prints each instruction as it is read (this cannot be used with the `l` flag).

For instance, if you do:
```
$ ./cstru main is_odd -o odd_check
```
(These are the files from the last lesson)  
The files `main` and `is_odd` will be compiled into a file named `odd_check`.

Let's say you have some file, let's call it `string_funcs.stru` that has a bunch of functions for manipulating strings. You want to be able to use this across multiple other programs, what you can do is like so:
```
$ ./cstru -c string_funcs.stru -o libstring.o
```
This will compile `string_funcs.stru` into an object file `libstring.o`. How does this help? Well, let's say you have another file, let's call it `main.stru`. `main.stru` uses functions defined in `string_funcs.h`. You could do:
```
$ ./cstru string_funcs.stru main.stru
```
Which will recompile `string_funcs.stru` and `main.stru` and link them together. While this works, this is slower if you have already compiled `string_funcs.stru`.  
So, you could do:
```
$ ./cstru -c main.stru -o main.o
$ ./cstru -l main.o libstring.o
```
This will compile `main.stru` into an object file `main.o` and then link `main.o` and `libstring.o`.   

<br>

## **The interpreter**

The interpreter, which is the executable `stru`, interprets "executables" generated by the compiler (`cstru`) and executes them accordingly.

### Operation
The interpreter is pretty straightforward. It's essentially just a large switch statement that reads from the executable and then does actions accordingly.

### Usage
The interpreter has the following usage:  
<code>stru [<u>FLAGS</u>] <<u>FILE</u>></code>  

The interpreter supports the following flags:

+ `h` - a quick description about the interpreter.
+ `s` - prints the stack after each set of instructions is executed.
+ `i` - prints each set of instructions after they are read.
+ `r` - prints the state of the registers after each set of instructions is executed.
+ `f` - prints the state of the flags after each set of instructions is executed.